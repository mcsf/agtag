#!/bin/sh

TARGET="$1"

: "${AG_FMT_OPTS:=-o --noheading --nobreak}"
: "${AG_JS_OPTS:=--js --ts}"
: "${AG_PHP_OPTS:=--php}"

# export default forwardRef( Component )
JS_WRAPPED_EXPORT='^export default \w+\( \K\w+'
# export async function *foo() {}
JS_SINGLE_EXPORTS='^export (default )?(async )?(function( | *\* *)|class |const |interface )?\K\w+'
# export { foo as default, bar }
JS_OBJECT_EXPORTS='^export \K{\s*(\w+,?\s+)*}' # Intentionally capture the surrounding braces
# /** @typedef {import(...).Props} MyProps
JS_JSDOC_TYPEDEFS='@typedef ({[^}]+} )?\K\w+'
JS_ALL="($JS_WRAPPED_EXPORT)|($JS_SINGLE_EXPORTS)|($JS_OBJECT_EXPORTS)|($JS_JSDOC_TYPEDEFS)"

PHP_ALL='^\s*(public |protected |private |static )*(function |class )\K\w+'

find_symbols() {
	# shellcheck disable=2086
	ag $AG_FMT_OPTS $AG_JS_OPTS "$JS_ALL" "${TARGET:=.}"
	# shellcheck disable=2086
	ag $AG_FMT_OPTS $AG_PHP_OPTS "$PHP_ALL" "${TARGET:=.}"
}

# Intercept exports like "{ A as B, C }" and, for each export, produce a tag
# only for its new name, i.e. "B" and "C".
fix_js_obj_exports() {
	awk -F: '
		$3 ~ /{/ { on = 1 }
		! on
		on {
			sub("{", "", $3)
			split($3, exports, /\s*,\s*/)
			for (i in exports) {
				n = split(exports[i], words, /\s+/)
				if (words[n] && words[n] != "}")
					print $1 ":" $2 ":" words[n]
			}
		}
		$3 ~ /}/ { on = 0 }
	'
}

format_tags() {
	awk -F: 'BEGIN{OFS="\t"} {print $3, $1, $2 ";\""}'
}

find_symbols | fix_js_obj_exports | format_tags | sort
